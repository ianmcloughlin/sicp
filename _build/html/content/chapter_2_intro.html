
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>2. Building Abstractions with Data &#8212; Structure and Interpretation of Computer Programs</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet">
  <link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script>
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="2.1. Introduction to Data Abstraction" href="chapter_2_section_1.html" />
    <link rel="prev" title="1.3. Formulating Abstractions with Higher-Order Procedures" href="chapter_1_section_3.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Structure and Interpretation of Computer Programs</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="_preamble_01_title.html">
   Structure and Interpretation
   <br/>
   of Computer Programs
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Preamble
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="_preamble_02_license.html">
   License
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="_preamble_03_ordering.html">
   Ordering Information
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="_preamble_04_dedication.html">
   Dedication
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="_preamble_05_foreword.html">
   Foreword
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="_preamble_06_preface_second.html">
   Preface to the Second Edition
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="_preamble_07_preface_first.html">
   Preface to the First Edition
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="_preamble_08_acknowledgments.html">
   Acknowledgments
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Book
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="chapter_1_intro.html">
   1. Building Abstractions with Procedures
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="chapter_1_section_1.html">
     1.1. The Elements of Programming
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="chapter_1_section_2.html">
     1.2. Procedures and the Processes They Generate
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="chapter_1_section_3.html">
     1.3. Formulating Abstractions with Higher-Order Procedures
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="current reference internal" href="#">
   2. Building Abstractions with Data
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="chapter_2_section_1.html">
     2.1. Introduction to Data Abstraction
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="chapter_2_section_2.html">
     2.2. Hierarchical Data and the Closure Property
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="chapter_2_section_3.html">
     2.3. Symbolic Data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="chapter_2_section_4.html">
     2.4. Multiple Representations for Abstract Data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="chapter_2_section_5.html">
     2.5. Systems with Generic Operations
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="chapter_3_intro.html">
   3. Modularity, Objects, and State
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="chapter_3_section_1.html">
     3.1. Assignment and Local State
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="chapter_3_section_2.html">
     3.2. The Environment Model of Evaluation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="chapter_3_section_3.html">
     3.3. Modeling with Mutable Data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="chapter_3_section_4.html">
     3.4. Concurrency: Time Is of the Essence
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="chapter_3_section_5.html">
     3.5. Streams
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="chapter_4_intro.html">
   4. Metalinguistic Abstraction
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="chapter_4_section_1.html">
     4.1. The Metacircular Evaluator
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="chapter_4_section_2.html">
     4.2. Variations on a Scheme – Lazy Evaluation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="chapter_4_section_3.html">
     4.3. Variations on a Scheme – Nondeterministic Computing
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="chapter_4_section_4.html">
     4.4. Logic Programming
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="chapter_5_intro.html">
   5. Computing with Register Machines
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="chapter_5_section_1.html">
     5.1. Designing Register Machines
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="chapter_5_section_2.html">
     5.2. A Register-Machine Simulator
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="chapter_5_section_3.html">
     5.3. Storage Allocation and Garbage Collection
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="chapter_5_section_4.html">
     5.4. The Explicit-Control Evaluator
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="chapter_5_section_5.html">
     5.5. Compilation
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Postamble
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="postamble_01_references.html">
   References
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="postamble_02_exercises.html">
   Exercises
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="postamble_03_index.html">
   Index
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/content/chapter_2_intro.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/ianmcloughlin/sicp"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/ianmcloughlin/sicp/issues/new?title=Issue%20on%20page%20%2Fcontent/chapter_2_intro.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="building-abstractions-with-data">
<span id="chapter-2"></span><h1><span class="section-number">2. </span>Building Abstractions with Data<a class="headerlink" href="#building-abstractions-with-data" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p>We now come to the decisive step of mathematical abstraction: we forget about what the symbols stand for. <tt>…</tt>[The mathematician] need not be idle; there are many operations which he may carry out with these symbols, without ever having to look at the things they stand for.
— Hermann Weyl, <em>The Mathematical Way of Thinking</em></p>
</div></blockquote>
<p><a name="index_term_1256"></a><a name="index_term_1258"></a>We concentrated in chapter 1 on computational processes and on the role of procedures in program design. We saw how to use primitive data (numbers) and primitive operations (arithmetic operations), how to combine procedures to form compound procedures through composition, conditionals, and the use of parameters, and how to abstract procedures by using <tt>define</tt>. We saw that a procedure can be regarded as a pattern for the local evolution of a process, and we classified, reasoned about, and performed simple algorithmic analyses of some common patterns for processes as embodied in procedures. We also saw that higher-order procedures enhance the power of our language by enabling us to manipulate, and thereby to reason in terms of, general methods of computation. This is much of the essence of programming.</p>
<p>In this chapter we are going to look at more complex data. All the procedures in chapter 1 operate on simple numerical data, and simple data are not sufficient for many of the problems we wish to address using computation. Programs are typically designed to model complex phenomena, and more often than not one must construct computational objects that have several parts in order to model real-world phenomena that have several aspects. Thus, whereas our focus in chapter 1 was on building abstractions by combining procedures to form compound procedures, we turn in this chapter to another key aspect of any programming language: the means it provides for building abstractions by combining data objects to form <em>compound data</em>.</p>
<p>Why do we want compound data in a programming language? For the same reasons that we want compound procedures: to elevate the conceptual level at which we can design our programs, to increase the modularity of our designs, and to enhance the expressive power of our language. Just as the ability to define procedures enables us to deal with processes at a higher conceptual level than that of the primitive operations of the language, the ability to construct compound data objects enables us to deal with data at a higher conceptual level than that of the primitive data objects of the language.</p>
<p><a name="index_term_1260"></a>Consider the task of designing a system to perform arithmetic with rational numbers. We could imagine an operation <tt>add-rat</tt> that takes two rational numbers and produces their sum. In terms of simple data, a rational number can be thought of as two integers: a numerator and a denominator. Thus, we could design a program in which each rational number would be represented by two integers (a numerator and a denominator) and where <tt>add-rat</tt> would be implemented by two procedures (one producing the numerator of the sum and one producing the denominator). But this would be awkward, because we would then need to explicitly keep track of which numerators corresponded to which denominators. In a system intended to perform many operations on many rational numbers, such bookkeeping details would clutter the programs substantially, to say nothing of what they would do to our minds. It would be much better if we could “glue together” a numerator and denominator to form a pair – a <em>compound data object</em> – that our programs could manipulate in a way that would be consistent with regarding a rational number as a single conceptual unit.</p>
<p>The use of compound data also enables us to increase the modularity of our programs. If we can manipulate rational numbers directly as objects in their own right, then we can separate the part of our program that deals with rational numbers per se from the details of how rational numbers may be represented as pairs of integers. The general technique of isolating the parts of a program that deal with how data objects are represented from the parts of a program that deal with how data objects are used is a powerful design methodology called <a name="index_term_1262"></a><em>data abstraction</em>. We will see how data abstraction makes programs much easier to design, maintain, and modify.</p>
<p>The use of compound data leads to a real increase in the expressive power of our programming language. Consider the idea of forming a “linear combination” <em>a**x</em> + <em>b**y</em>. We might like to write a procedure that would accept <em>a</em>, <em>b</em>, <em>x</em>, and <em>y</em> as arguments and return the value of <em>a**x</em> + <em>b**y</em>. This presents no difficulty if the arguments are to be numbers, because we can readily define the procedure</p>
<p><tt>(define (linear-combination a b x y) <br>
  (+ (<em> a x) (</em> b y)))<br></tt></p>
<p>But suppose we are not concerned only with numbers. Suppose we would like to express, in procedural terms, the idea that one can form linear combinations whenever addition and multiplication are defined – for rational numbers, complex numbers, polynomials, or whatever. We could express this as a procedure of the form</p>
<p><tt>(define (linear-combination a b x y)     <br>
  (add (mul a x) (mul b y))) <br></tt></p>
<p>where <tt>add</tt> and <tt>mul</tt> are not the primitive procedures <tt>+</tt> and <tt>*</tt> but rather more complex things that will perform the appropriate operations for whatever kinds of data we pass in as the arguments <tt>a</tt>, <tt>b</tt>, <tt>x</tt>, and <tt>y</tt>. The key point is that the only thing <tt>linear-combination</tt> should need to know about <tt>a</tt>, <tt>b</tt>, <tt>x</tt>, and <tt>y</tt> is that the procedures <tt>add</tt> and <tt>mul</tt> will perform the appropriate manipulations. From the perspective of the procedure <tt>linear-combination</tt>, it is irrelevant what <tt>a</tt>, <tt>b</tt>, <tt>x</tt>, and <tt>y</tt> are and even more irrelevant how they might happen to be represented in terms of more primitive data. This same example shows why it is important that our programming language provide the ability to manipulate compound objects directly: Without this, there is no way for a procedure such as <tt>linear-combination</tt> to pass its arguments along to <tt>add</tt> and <tt>mul</tt> without having to know their detailed structure.<a name="call_footnote_Temp_131" href="#footnote_Temp_131" id="call_footnote_Temp_131"><sup><small>1</small></sup></a> We begin this chapter by implementing the rational-number arithmetic system mentioned above. This will form the background for our discussion of compound data and data abstraction. As with compound procedures, the main issue to be addressed is that of abstraction as a technique for coping with complexity, and we will see how data abstraction enables us to erect suitable <a name="index_term_1264"></a><em>abstraction barriers</em> between different parts of a program.</p>
<p>We will see that the key to forming compound data is that a programming language should provide some kind of “glue” so that data objects can be combined to form more complex data objects. There are many possible kinds of glue. Indeed, we will discover how to form compound data using no special “data” operations at all, only procedures. This will further blur the distinction between “procedure” and “data,” which was already becoming tenuous toward the end of chapter 1. We will also explore some conventional techniques for representing sequences and trees. One key idea in dealing with compound data is the notion of <a name="index_term_1266"></a><em>closure</em> – that the glue we use for combining data objects should allow us to combine not only primitive data objects, but compound data objects as well. Another key idea is that compound data objects can serve as <a name="index_term_1268"></a><em>conventional interfaces</em> for combining program modules in mix-and-match ways. We illustrate some of these ideas by presenting a simple graphics language that exploits closure.</p>
<p>We will then augment the representational power of our language by introducing <a name="index_term_1270"></a><a name="index_term_1272"></a><em>symbolic expressions</em> – data whose elementary parts can be arbitrary symbols rather than only numbers. We explore various alternatives for representing sets of objects. We will find that, just as a given numerical function can be computed by many different computational processes, there are many ways in which a given data structure can be represented in terms of simpler objects, and the choice of representation can have significant impact on the time and space requirements of processes that manipulate the data. We will investigate these ideas in the context of symbolic differentiation, the representation of sets, and the encoding of information.</p>
<p>Next we will take up the problem of working with data that may be represented differently by different parts of a program. This leads to the need to implement <a name="index_term_1274"></a><a name="index_term_1276"></a><em>generic operations</em>, which must handle many different types of data. Maintaining modularity in the presence of generic operations requires more powerful abstraction barriers than can be erected with simple data abstraction alone. In particular, we introduce <em>data-directed programming</em> as a technique that allows individual data representations to be designed in isolation and then combined <a name="index_term_1278"></a><em>additively</em> (i.e., without modification). To illustrate the power of this approach to system design, we close the chapter by applying what we have learned to the implementation of a package for performing symbolic arithmetic on polynomials, in which the coefficients of the polynomials can be integers, rational numbers, complex numbers, and even other polynomials.</p>
<div class="smallprint">
  <hr>
</div>
<div class="footnote">
<p><a name="footnote_Temp_131" href="#call_footnote_Temp_131" id="footnote_Temp_131"><sup><small>1</small></sup></a> The ability to directly manipulate procedures provides an analogous increase in the expressive power of a programming language. For example, in section <a href="chapter_1_section_3.html#%_sec_1.3.1">1.3.1</a> we introduced the <tt>sum</tt> procedure, which takes a procedure <tt>term</tt> as an argument and computes the sum of the values of <tt>term</tt> over some specified interval. In order to define <tt>sum</tt>, it is crucial that we be able to speak of a procedure such as <tt>term</tt> as an entity in its own right, without regard for how <tt>term</tt> might be expressed with more primitive operations. Indeed, if we did not have the notion of “a procedure,” it is doubtful that we would ever even think of the possibility of defining an operation such as <tt>sum</tt>. Moreover, insofar as performing the summation is concerned, the details of how <tt>term</tt> may be constructed from more primitive operations are irrelevant.</p>
</div><div class="toctree-wrapper compound">
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./content"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
            <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="chapter_1_section_3.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">1.3. </span>Formulating Abstractions with Higher-Order Procedures</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="chapter_2_section_1.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">2.1. </span>Introduction to Data Abstraction</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
        
        </div>
    </div>
    <footer class="footer">
    <div class="container">
      <p>
        
          By Harold Abelson and Gerald Jay Sussman<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>